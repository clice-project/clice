import{_ as t,c as a,o,ae as n}from"./chunks/framework.D8webtH5.js";const u=JSON.parse('{"title":"What is clice?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/what-is-clice.md","filePath":"en/guide/what-is-clice.md"}'),i={name:"guide/what-is-clice.md"};function s(r,e,l,d,h,c){return o(),a("div",null,e[0]||(e[0]=[n('<h1 id="what-is-clice" tabindex="-1">What is clice? <a class="header-anchor" href="#what-is-clice" aria-label="Permalink to &quot;What is clice?&quot;">​</a></h1><p>clice is a completely new C++ language server designed to address the shortcomings of existing C++ language servers. It provides code navigation and intelligent suggestions for your editor.</p><h2 id="why-a-new-language-server" tabindex="-1">Why a New Language Server? <a class="header-anchor" href="#why-a-new-language-server" aria-label="Permalink to &quot;Why a New Language Server?&quot;">​</a></h2><p>So the first question is, why develop a new language server? Is it necessary to reinvent the wheel?</p><p>This question deserves a serious answer. Before this project, I had written many projects, both large and small. But the vast majority of them were toy projects, written only to verify some idea or for personal learning, without solving any real problems. clice is not like that - it genuinely intends to solve existing problems (specific problems will be discussed later), rather than rewriting for the sake of rewriting.</p><p>At the beginning of this year, I wanted to participate in the development of the LLVM project. I wanted to start from what I&#39;m more familiar with - C++, specifically clang. But without requirements, I couldn&#39;t just stare at the source code. The normal process in such cases is to start with some &quot;first issues&quot; and gradually get familiar with the project. But I found this boring - I wanted to do something big right from the start, like implementing some new C++ standard feature. However, I found there was almost no place for me to get involved here, as new feature implementations are almost always completed by a few core clang developers. Well, since there&#39;s no opportunity here, let&#39;s look elsewhere. My attention naturally shifted to clangd, since I mainly use VSCode for development, and the best C++ language server on VSCode is clangd.</p><p>At the time, I knew nothing about clangd, except that I found it seemed to render keyword highlighting incorrectly. So I started reading clangd&#39;s source code while browsing through clangd&#39;s numerous issues to see if there was anything I could solve. After going through hundreds of issues, I found there were quite a few problems here. At the time, I was particularly interested in an <a href="https://github.com/clangd/clangd/issues/443" target="_blank" rel="noreferrer">issue</a> about code completion within templates. Why was I interested in this? Readers familiar with me might know that I&#39;m quite an experienced metaprogramming player, having written many related articles before. Naturally, I&#39;m not only curious about how template metaprogramming itself works, but also curious about how clang, as a compiler, implements related features. This issue was a good entry point for me. After spending several weeks exploring prototype implementations, I initially solved that issue, <strong>but then I found that there was no one to review the related code!</strong></p><p>After some investigation, I found that clangd&#39;s current situation is quite bad. Let&#39;s go through the timeline: clangd was originally just a simple small project within LLVM, not outstanding in terms of functionality and usability. As MaskRay mentioned in this <a href="https://maskray.me/blog/2017-12-03-c++-language-server-cquery" target="_blank" rel="noreferrer">blog post</a> about ccls, clangd at the time could only handle single compilation units, and cross-compilation unit requests couldn&#39;t be processed. This blog post was published in 2017, which is also one reason why MaskRay chose to write ccls. ccls is also a C/C++ language server that was stronger than clangd at that point. However, later, Google started sending people to improve clangd to meet their internal large codebase needs. At the same time, the LSP standard content was constantly expanding, and clangd was continuously following up on new standard content, but ccls&#39;s author seemed to gradually become busy with other things and didn&#39;t have much time to maintain ccls. So in the end, clangd had surpassed ccls overall. The turning point occurred around 2023, when clangd seemed to have reached a highly usable state for Google internally, and the original employees responsible for clangd were transferred to do other things. Currently, clangd&#39;s issues are mainly handled by only one person, <a href="https://github.com/HighCommander4" target="_blank" rel="noreferrer">HighCommander4</a>, purely out of passion, not employed by anyone. Since he&#39;s not specifically employed to maintain clangd, he can only handle issues in his limited free time, and only limited to answering questions and very limited reviews. As he mentioned in this <a href="https://github.com/clangd/clangd/issues/1690#issuecomment-1619735578" target="_blank" rel="noreferrer">comment</a>:</p><blockquote><p>The other part of the reason is lack of resources to pursue the ideas we do have, such as the idea mentioned above of trying to shift more of the burden to disk usage through more aggressive preamble caching. I&#39;m a casual contributor, and the limited time I have to spend on clangd is mostly taken up by answering questions, some code reviews, and the occasional small fix / improvement; I haven&#39;t had the bandwidth to drive this type of performance-related experimentation.</p></blockquote><p>Given this situation, it&#39;s not surprising that large PRs like <a href="https://github.com/llvm/llvm-project/pull/66462" target="_blank" rel="noreferrer">preliminary support for C++20 modules</a> for clangd have been delayed for nearly a year. After realizing this current state, I had the idea of writing a language server myself. I estimated the project size - removing test code, it would take about 20,000 lines to complete, which is a workload that one person can accomplish over a period of time, and there are precedents like ccls and rust-analyzer. Another point is that clangd&#39;s code is already dated - despite having many comments, the related logic is still very convoluted, and the time spent on large-scale modifications might not be faster than rewriting.</p><p>So I got to work. I categorized clangd&#39;s hundreds of issues to see if there were some problems that were difficult to solve due to clangd&#39;s initial architectural design errors and were therefore shelved. If so, could these be considered and solved during redesign? I found that there were indeed some! So in the following time, I spent about two months learning and researching the related mechanisms in clang, exploring solutions to related problems, and exploring prototype implementations. After confirming that the related problems could basically be solved, I officially started the development of clice.</p>',11)]))}const m=t(i,[["render",s]]);export{u as __pageData,m as default};
